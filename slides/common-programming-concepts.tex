\section{Common Programming Concepts}

\begin{frame}[fragile]{Variables}
    \begin{code}[basicstyle=\footnotesize]
    fn main() {
        let x = 5; // immutable variable and type inference
        let mut y = 6; // mutable variable and type inference
        const Y2K: i32 = 2000; // const variables require a known type
        static mut POTATOES: u32 = 0; // This is a mutable static variable
    }
    \end{code}
\end{frame}

\begin{frame}[fragile]{Variables: Shadowing}
    \centering
    \begin{code}[]
    fn main() {
        let x = 5;
        let x = x + 1;
        {
            let x = x * 2;
            println!("The value of x is: {x}"); // 12
        }
        println!("The value of x is: {x}"); // 6
    }
    \end{code}
\end{frame}

\begin{frame}{Scalar Data Types}
    \begin{table}[]
        \caption*{\textbf{Integer Types}}
        \begin{tabular}{|c|c|c|}
        \hline
        \rowcolor[HTML]{C0C0C0} 
        Length & Signed & Unsigned \\ \hline
        8-bit  & i8     & u8       \\ \hline
        16-bit & i16    & u16      \\ \hline
        32-bit & i32    & u32      \\ \hline
        64-bit & i64    & u64      \\ \hline
        \end{tabular}
    \end{table}

    \begin{table}[]
        \caption*{\textbf{Floating-point Types}}
        \begin{tabular}{|c|c|}
        \hline
        \rowcolor[HTML]{C0C0C0} 
        Length &        \\ \hline
        32-bit & f32    \\ \hline
        64-bit & f64    \\ \hline
        \end{tabular}
    \end{table}
\end{frame}

\begin{frame}[fragile]{Compound Types: Tuple Type}
    \begin{code}
        fn main() {
            // implicit declaration using type inference
            let tup = (500, 6.4, 1); 
            // explicit declaration
            let tup: (i32, f64, u8) = (500, 6.4, 1);

            println!("The first value is: {tup.0}");

            let (x, y, z) = tup; // destructuring
            println!("The first value is: {y}");
        }
    \end{code}
\end{frame}

\begin{frame}[fragile]{Compound Types: Array Type}
    \begin{code}
        fn main() {
            // implicit declaration using type inference
            let a = [1, 2, 3, 4, 5];
            // explicit declaration
            let a: [i32; 5] = [1, 2, 3, 4, 5];

            // Fast init
            let a = [3; 5]; // [3, 3, 3, 3, 3]

            let first = a[0]; // first element of a
        }
    \end{code}
\end{frame}

\begin{frame}[fragile]{Control Flow: if Expressions}
    \begin{code}
        fn main() {
            let number = 6;

            if number % 4 == 0 {
                println!("number is divisible by 4");
            } else if number % 3 == 0 {
                println!("number is divisible by 3");
            } else if number % 2 == 0 {
                println!("number is divisible by 2");
            } else {
                println!("number is not divisible by 4, 3, or 2");
            }
        }
    \end{code}
\end{frame}

\begin{frame}[fragile]{Control Flow: using if in a let Statement}
    \begin{code}
        fn main() {
            let condition = true;
            let number = if condition { 5 } else { 6 };
            // values must be of the same type

            println!("The value of number is: {number}"); // 6
        }
    \end{code}
\end{frame}

\begin{frame}[fragile]{Control Flow: Loop}
    \begin{code}
        fn main() {
            let mut counter: i32 = 0;

            loop {
                if counter == 10 {
                    break;
                }

                println!("counter: {}", &counter);
                counter += 1;
            }
        }
    \end{code}
\end{frame}

\begin{frame}[fragile]{Control Flow: returning values from loops}
    \begin{code}
        fn main() {
            let mut counter = 0;

            let result = loop {
                counter += 1;

                if counter == 10 {
                    break counter * 2;
                }
            };

            println!("The result is {result}"); // 20
        }
    \end{code}
\end{frame}

\begin{frame}[fragile]{Control Flow: loop labels}
    \begin{code}[basicstyle=\footnotesize]
        fn main() {
            let mut count = 0;
            'counting_up: loop {
                println!("count = {count}");
                let mut remaining = 10;
                loop {
                    println!("remaining = {remaining}");
                    if remaining == 9 {
                        break;
                    }
                    if count == 2 {
                        break 'counting_up;
                    }
                    remaining -= 1;
                }
                count += 1;
            }
            println!("End count = {count}");
        }
    \end{code}
\end{frame}

\begin{frame}[fragile]{Control Flow: while}
    \begin{code}
        fn main() {
            let mut number = 3;

            while number != 0 {
                println!("{number}!");

                number -= 1;
            }

            println!("LIFTOFF!!!");
        }
    \end{code}
\end{frame}

\begin{frame}[fragile]{Control Flow: for}
    \begin{code}
        fn main() {
            // for loop using Range from std
            for number in (1..4).rev() {
                println!("{number}!");
            }

            println!("LIFTOFF!!!");
        }
    \end{code}
\end{frame}

\begin{frame}[fragile]{Control Flow: Looping Through a Collection}
    \begin{code}
        fn main() {
            let a = [10, 20, 30, 40, 50];

            for element in a {
                println!("the value is: {element}");
            }
        }
    \end{code}
\end{frame}

\begin{frame}[fragile]{Functions}
    \begin{code}
        fn main() {
            let x = plus_one(5);

            println!("The value of x is: {x}");
        }

        fn plus_one(x: i32) -> i32 {
            x + 1 // expression (without semicolons)
        }
    \end{code}
\end{frame}